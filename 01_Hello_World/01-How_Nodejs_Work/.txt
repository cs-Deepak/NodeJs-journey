

# ğŸ“’ Node.js Working Notes

### âš¡ Node.js Overview

* Node.js is a **JavaScript runtime** built on **Google Chromeâ€™s V8 engine**.
* It follows an **event-driven, non-blocking I/O model** â†’ lightweight & efficient for scalable apps.

---

### ğŸ”„ Request & Response Cycle

1. **Client sends request** â†’ (HTTP request, DB query, file read, etc.)
2. **Node.js receives request** â†’ enters **Event Loop**.
3. If request is **non-blocking (async I/O)** â†’ handled by **event loop** with help of **Thread Pool**.
4. If request is **blocking (sync operation)** â†’ Node.js main thread is blocked until task finishes.
5. **Response is sent back** to the client.

---

### ğŸŒ€ Event Loop

* The **core mechanism** of Node.js.
* Keeps listening for events/callbacks & executes them in phases.
* Phases of Event Loop:

  1. **Timers** â†’ setTimeout, setInterval
  2. **Pending Callbacks** â†’ I/O callbacks waiting
  3. **Idle/Prepare** â†’ internal use
  4. **Poll** â†’ get new I/O events, execute I/O callbacks
  5. **Check** â†’ setImmediate callbacks
  6. **Close callbacks** â†’ e.g., `socket.on('close')`

---

### ğŸš« Blocking Operation

* **Blocks main thread** until task finishes.
* Example:

  ```js
  const fs = require('fs');
  const data = fs.readFileSync('file.txt'); // Blocking
  console.log("This runs after file is read");
  ```
* Problem â†’ slows down performance if many requests.

---

### âœ… Non-Blocking Operation

* **Does not block main thread** â†’ handled asynchronously.
* Example:

  ```js
  const fs = require('fs');
  fs.readFile('file.txt', (err, data) => { // Non-Blocking
    console.log("File read complete");
  });
  console.log("This runs immediately");
  ```
* Advantage â†’ Node.js can handle **thousands of requests concurrently**.

---

### ğŸ‘¥ Thread Pool (libuv)

* Node.js itself is **single-threaded**, but uses **libuv** for async tasks.
* libuv manages a **Thread Pool (default 4 threads)** â†’ handles tasks like:

  * File system operations
  * DNS lookups
  * Crypto operations (hashing, encryption)
  * Compression
* After execution â†’ result is passed back to **Event Loop** â†’ callback executed.

---

### ğŸ“Œ Summary

* Node.js = **Single-threaded event loop + Thread Pool for heavy I/O**.
* **Non-blocking I/O** â†’ efficient for real-time apps.
* **Blocking code** should be avoided in main thread.
* Great for APIs, chat apps, streaming, but not for **CPU-heavy tasks** (unless offloaded to worker threads).

---


Note :- Default Thread Pool Size = 4.
Max? - 9core cpu - 8



 ğŸŒ Client (Request)
          â”‚
          â–¼
   ğŸŸ¢ Event Loop
          â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                â”‚
   â–¼                â–¼
â›” Blocking      ğŸ‘¥ Thread Pool (libuv)
(Main thread)     (Async I/O: File, DB, DNS, Crypto)
   â”‚                â”‚
   â–¼                â”‚
ğŸ“¤ Response  â—€â”€â”€â”€â”€â”€â”€â”˜
   (to Client)

